OUR HACK IDEA - BREAKDOWN 
The Problem
Imagine you're a trader on Hyperliquid (a crypto exchange). You have $1,000 and want to make more money by borrowing from the exchange to trade with more capital. Here's how it works:
Key Trading Concepts
Position: Your active trade. Example: "I own 10 Bitcoin right now"
Leverage: Borrowing multiplier. If you have $1,000 and use 10x leverage, you can trade with $10,000 ($1,000 yours + $9,000 borrowed).
Entry Price: The price at which you opened your position. Example: Bitcoin at $45,000.
Liquidation Price: The "danger price." If the market drops to this price, the exchange automatically closes your position and takes your collateral ($1,000). You lose everything.
Example:
* You buy 10 BTC at $45,000 with $1,000 (10x leverage)
* Your liquidation price = $40,500 (simplified)
* If Bitcoin drops to $40,500 → liquidation happens
* Your $1,000 is gone
* You owe nothing more (exchange closes it automatically)
Loss Amount: How much money you lost when liquidated.
________________


The SafeKeeper Solution
SafeKeeper is insurance for liquidations.
Before SafeKeeper:
* Trader: "I'll risk my $1,000"
* If liquidated → $1,000 is gone forever
With SafeKeeper:
* Trader: "I'll pay $15/month insurance on my $1,000 position" (1.5% premium)
* If liquidated → SafeKeeper pays back 50% of the loss ($500)
* Net loss: $1,000 (position) - $500 (payout) = $500 lost instead of $1,000
________________


How SafeKeeper Works (Full Flow)
text
Step 1: Trader buys insurance
  └─ Position: $1,000 at 10x leverage
  └─ Premium paid: $15 (1.5%)
  └─ Payout if liquidated: 50% of loss = $500


Step 2: Liquidation happens (price drops)
  └─ Backend service detects liquidation
  └─ Backend calls smart contract


Step 3: Smart contract pays payout
  └─ Payout: $500 sent to trader's wallet
  └─ Pool balance reduced by $500
  └─ Policy marked as claimed


Step 4: Trader gets money back
  └─ Lost position: -$1,000
  └─ Insurance payout: +$500
  └─ Net loss: $500 (instead of $1,000)


________________


The Pool (Where Money Comes From)
SafeKeeper's pool is like an insurance fund:
* Pool gets funded: Many traders pay premiums ($15, $20, $30, etc.)
* Pool pays claims: When liquidations happen, pool pays payouts
Example:
* 100 traders pay $15 each in premiums = $1,500 in pool
* 5 traders get liquidated, each gets $500 payout = $2,500 needed
* Problem: Pool doesn't have enough!
* Solution: SafeKeeper adjusts premiums based on pool balance/risk
________________


Key Contracts (On-Chain)
1. Pricing.sol → Calculates how much premium to charge
2. PolicyRegistry.sol → Stores who bought insurance
3. InsurancePool.sol → Holds money, pays claims
________________


2. Hyperliquid - What It Is & How It Fits Into SafeKeeper
What is Hyperliquid?
Hyperliquid is a decentralized perpetual futures exchange (perp exchange).
Let me break that down:
Key Terms
Perpetual Futures (Perps):
* A contract that lets you bet on price movements without an expiration date
* Unlike normal futures that expire (e.g., "December Bitcoin futures"), perps go on forever
* You can close your position anytime
Example:
* "I think Bitcoin will go UP" → Buy 1 BTC perpetual at $45,000
* "I think Bitcoin will go DOWN" → Short 1 BTC perpetual at $45,000
Decentralized:
* Runs on blockchain (not a traditional bank/company like Binance)
* No KYC (Know Your Customer) — more anonymous
* Users control their own wallets (not the exchange)
________________


How Hyperliquid Works
Trading on Hyperliquid
1. Connect Wallet (MetaMask, etc.)
2. Deposit Collateral (e.g., $1,000 USDC)
3. Open Position with leverage (e.g., 10x)
   * Your $1,000 becomes $10,000 buying power
4. Monitor Position
   * If price goes up → You profit
   * If price goes down → You lose
5. Liquidation Risk
   * If losses exceed collateral → Position auto-closes
Example Trade
text
Scenario: Bitcoin at $45,000


Trader's Setup:
- Collateral: $1,000 USDC
- Leverage: 10x
- Position: LONG 0.22 BTC (buying)
- Entry Price: $45,000


Liquidation Price: $40,500
(If Bitcoin drops to this, position auto-closes)


Outcome A: Bitcoin rises to $50,000
- Profit: $1,100 (10% gain × 10x leverage)
- New balance: $2,100


Outcome B: Bitcoin drops to $40,500
- Loss: $1,000 (all collateral)
- Liquidated! Position closed, $0 left


________________


Where SafeKeeper Comes In
The Problem Hyperliquid Has
Hyperliquid traders face liquidation risk. If you miscalculate or market swings hard, you lose everything.
October 2025 Reality:
* Over $10 billion in liquidations on Hyperliquid in a single day
* Thousands of traders lost their entire collateral
SafeKeeper's Solution
SafeKeeper insures Hyperliquid positions:
text
Hyperliquid Position: $1,000 at 10x leverage
          ↓
SafeKeeper Insurance: $15 premium (1.5%)
          ↓
If liquidated on Hyperliquid:
  Backend detects it → Calls SafeKeeper contract → Pays $500


Result: Trader loses $500 instead of $1,000


________________


How SafeKeeper Detects Liquidations on Hyperliquid
SafeKeeper doesn't directly read Hyperliquid's data from contracts (Hyperliquid is centralized).
Instead:
1. Backend polls Hyperliquid API (REST/WebSocket)
   * Gets current prices
   * Gets user position states
   * Detects liquidations
2. When liquidation detected:
   * Backend calculates payout
   * Calls InsurancePool.submitClaim() on-chain
   * Pays user
3. On-chain contract:
   * Validates claim
   * Transfers payout to user
________________


Key Point: Hyperliquid ↔ SafeKeeper Flow
text
┌────────────────────────────────┐
│     Hyperliquid (Centralized)  │
│  - Runs the exchange           │
│  - Detects liquidations        │
│  - Auto-closes positions       │
└────────────────────────────────┘
              ↓
        Hyperliquid API
   (Provides price/position data)
              ↓
┌────────────────────────────────┐
│    SafeKeeper Backend Service  │
│  - Polls Hyperliquid API       │
│  - Detects insured liquidations│
│  - Submits claims on-chain     │
└────────────────────────────────┘
              ↓
    Smart Contract Call
   (submitClaim + payout)
              ↓
┌────────────────────────────────┐
│   SafeKeeper Smart Contracts   │
│  - Validates claim             │
│  - Pays trader's wallet        │
└────────────────────────────────┘


________________


Simple Summary
* Hyperliquid = Exchange where traders use leverage and risk liquidation
* SafeKeeper = Insurance that pays when Hyperliquid liquidates you
* Backend = Watches Hyperliquid, detects liquidations, triggers payouts
* Contracts = Hold pool money, execute payouts
________________


3. Backend Implementation - How to Talk to Hyperliquid
Backend Overview
Your backend is a Node.js service that:
1. Monitors Hyperliquid for insured traders' positions
2. Detects liquidations
3. Calls your smart contracts to pay out insurance
4. Provides REST API + WebSocket to frontend
________________


How to Talk to Hyperliquid (API Integration)
Hyperliquid API
Hyperliquid provides REST API + WebSocket for real-time data.
Base URL: https://api.hyperliquid.xyz
________________


Key Hyperliquid API Endpoints
1. Get User Positions
Endpoint: POST https://api.hyperliquid.xyz/info
Request:
javascript
const request = {
  type: "clearinghouseState",
  user: "0x1234...abc", // User's wallet address
};


const response = await fetch("https://api.hyperliquid.xyz/info", {
  method: "POST",
  body: JSON.stringify(request),
});


const data = await response.json();
// Returns: { positions: [ { coin, leverage, szi, px, ... } ] }


Response Example:
json
{
  "positions": [
    {
      "coin": "BTC",
      "leverage": 10,
      "szi": "0.22",           // Size (0.22 BTC)
      "px": "45000",           // Current price
      "positionValue": "9900", // Position worth
      "liquidationPx": "40500",// Liquidation price
      "unrealizedPnl": "1100"  // Unrealized profit/loss
    }
  ]
}


________________


2. Get Current Price
Endpoint: POST https://api.hyperliquid.xyz/info
Request:
javascript
const request = {
  type: "metaAndAssetCtxs",
};


const response = await fetch("https://api.hyperliquid.xyz/info", {
  method: "POST",
  body: JSON.stringify(request),
});


const data = await response.json();
// Returns: All active assets with current prices


Response Example:
json
[
  {
    "coin": "BTC",
    "markPx": "45000",
    "midPx": "45100",
    ...
  },
  {
    "coin": "ETH",
    "markPx": "2500",
    ...
  }
]


________________


Liquidation Detection Logic
Step 1: Store Insured Positions in Backend
When a trader buys insurance via your frontend:
javascript
// Backend receives from frontend:
{
  userAddress: "0x1234...abc",
  positionSize: "100",        // ETH
  leverage: 10,
  liquidationPrice: 2850,
  premiumPaid: 1.5,
  policyId: "policy_123"
}


// Backend stores in database:
db.insuredPositions.insert({
  userAddress: "0x1234...abc",
  liquidationPrice: 2850,
  policyId: "policy_123",
  claimed: false
});


________________


Step 2: Poll Hyperliquid Every 5 Seconds
javascript
// backend/services/liquidationDetector.js


const detectLiquidations = async () => {
  // Get all insured positions from DB
  const insuredPositions = await db.insuredPositions.find({ claimed: false });


  for (const policy of insuredPositions) {
    // Get user's current position from Hyperliquid
    const response = await fetch("https://api.hyperliquid.xyz/info", {
      method: "POST",
      body: JSON.stringify({
        type: "clearinghouseState",
        user: policy.userAddress,
      }),
    });


    const hyperData = await response.json();
    const position = hyperData.positions[0]; // Assume 1 position per user for MVP


    if (!position) {
      // Position closed/liquidated
      console.log(`Position liquidated for ${policy.userAddress}`);
      
      // Trigger payout
      await submitClaimToContract(policy);
      continue;
    }


    // Check if current price is at/below liquidation price
    const currentPrice = parseFloat(position.px);
    const liquidationPrice = parseFloat(policy.liquidationPrice);


    if (currentPrice <= liquidationPrice) {
      console.log(`Liquidation detected for ${policy.userAddress}`);
      
      // Calculate loss from position value
      const loss = parseFloat(position.szi) * currentPrice;
      
      // Trigger payout
      await submitClaimToContract(policy, loss);
    }
  }


  // Run again in 5 seconds
  setTimeout(detectLiquidations, 5000);
};


________________


Step 3: Submit Claim to Smart Contract
javascript
// backend/services/claimSubmitter.js


import { ethers } from "ethers";


const submitClaimToContract = async (policy, lossAmount) => {
  // Connect to blockchain
  const provider = new ethers.JsonRpcProvider(process.env.RPC_URL);
  const wallet = new ethers.Wallet(process.env.ADMIN_PRIVATE_KEY, provider);


  // Load InsurancePool contract
  const poolABI = [
    {
      name: "submitClaim",
      type: "function",
      inputs: [
        { name: "user", type: "address" },
        { name: "lossAmount", type: "uint256" },
      ],
      stateMutability: "nonpayable",
    },
  ];


  const pool = new ethers.Contract(
    process.env.INSURANCE_POOL_ADDRESS,
    poolABI,
    wallet
  );


  try {
    // Call submitClaim on contract
    const tx = await pool.submitClaim(
      policy.userAddress,
      ethers.parseEther(lossAmount.toString())
    );


    console.log(`Claim submitted. TxHash: ${tx.hash}`);


    // Wait for confirmation
    const receipt = await tx.wait();


    // Mark policy as claimed in DB
    await db.insuredPositions.updateOne(
      { policyId: policy.policyId },
      { claimed: true, claimedAt: new Date(), txHash: tx.hash }
    );


    // Emit WebSocket event to frontend
    broadcastToFrontend({
      type: "CLAIM_PAID",
      user: policy.userAddress,
      payout: lossAmount * 0.5, // 50% coverage
      txHash: tx.hash,
    });


  } catch (error) {
    console.error("Error submitting claim:", error);
  }
};


________________


Backend API Endpoints (What You'll Build)
Your backend exposes REST API to frontend:
1. Get Premium Quote
javascript
// GET /api/insurance/quote
app.post("/api/insurance/quote", (req, res) => {
  const { positionSize, leverage, volatility } = req.body;
  
  // Call Pricing.sol to get premium
  const bps = 50 + leverage * 10 + volatility * 5;
  const premium = (positionSize * bps) / 10000;
  
  res.json({
    premium,
    coverage: 50, // 50%
    expectedPayout: premium * 0.5,
  });
});


2. Record Policy Purchase
javascript
// POST /api/insurance/buy
app.post("/api/insurance/buy", async (req, res) => {
  const { userAddress, positionSize, leverage, liquidationPrice, txHash } = req.body;
  
  // Store in DB
  await db.insuredPositions.insert({
    userAddress,
    positionSize,
    leverage,
    liquidationPrice,
    policyId: `policy_${Date.now()}`,
    createdAt: new Date(),
    claimed: false,
    txHash,
  });
  
  res.json({ policyId: `policy_${Date.now()}`, status: "active" });
});


3. Get Pool Status
javascript
// GET /api/pool/status
app.get("/api/pool/status", async (req, res) => {
  // Call contract to get pool data
  const poolStatus = await pool.getPoolStatus();
  
  res.json({
    poolBalance: poolStatus.balance,
    totalPremiums: poolStatus.totalPremiums,
    totalClaims: poolStatus.totalClaims,
    activePolicies: poolStatus.activePolicies,
  });
});


4. WebSocket for Real-Time Updates
javascript
// WS /ws
const wss = new WebSocket.Server({ port: 8080 });


let clients = [];


wss.on("connection", (ws) => {
  clients.push(ws);


  ws.on("message", (data) => {
    const msg = JSON.parse(data);
    if (msg.type === "subscribe") {
      console.log(`Client subscribed to: ${msg.channels}`);
    }
  });
});


// Broadcast liquidation events
const broadcastToFrontend = (event) => {
  clients.forEach((client) => {
    if (client.readyState === WebSocket.OPEN) {
      client.send(JSON.stringify(event));
    }
  });
};


________________


Full Backend Flow (Complete)
text
┌─────────────────────────────────────┐
│  Every 5 seconds:                   │
│  detectLiquidations()               │
└─────────────────────────────────────┘
           ↓
┌─────────────────────────────────────┐
│  Query Hyperliquid API              │
│  For each insured user:             │
│  - Get current position             │
│  - Get current price                │
└─────────────────────────────────────┘
           ↓
┌─────────────────────────────────────┐
│  Check liquidation condition:       │
│  currentPrice <= liquidationPrice?  │
└─────────────────────────────────────┘
           ↓
┌─────────────────────────────────────┐
│  If liquidated:                     │
│  - Calculate loss                   │
│  - submitClaim(user, loss)          │
│  - Update DB                        │
│  - Broadcast to WebSocket clients   │
└─────────────────────────────────────┘


________________


What You Need to Implement Backend
1. Node.js + Express for REST API
2. VIEM for contract calls
3. PostgreSQL to store insured positions - prisma orm
4. WebSocket library (ws) for real-time updates
5. Hyperliquid API client to poll positions
________________


Summary of Backend Architecture
Backend Service (Node.js)
├── Liquidation Detector
│   └─ Polls Hyperliquid every 5 seconds
│
├── Claim Submitter
│   └─ Calls InsurancePool.submitClaim()
│
├── REST API
│   ├─ POST /api/insurance/quote
│   ├─ POST /api/insurance/buy
│   ├─ GET /api/pool/status
│   └─ GET /api/insurance/policies/:user
│
└── WebSocket Server
    └─ Real-time updates to frontend


















Frontend → Backend & Contract Touchpoints
1) REST API Endpoints (frontend → backend)
Method
	Endpoint
	Called From
	Purpose
	POST
	/api/insurance/quote
	useInsurance.getQuote()
	Get premium quote for a position
	POST
	/api/insurance/buy
	useInsurance.buyInsurance()
	Record insurance purchase (after tx)
	GET
	/api/insurance/policies/:addr
	useInsurance.getPolicies()
	Fetch policies for a given wallet
	GET
	/api/pool/status
	usePool.fetchPoolStatus()
	Get pool balance, totals, active count
	(If you keep auth)
Method
	Endpoint
	Called From
	Purpose
	GET
	/api/auth/nonce
	auth flow (optional)
	Get nonce for SIWE
	POST
	/api/auth/verify
	auth flow (optional)
	Verify signed message, issue JWT
	________________


2) WebSocket Messages (frontend ↔ backend)
Direction
	Message Type
	Sent/Handled By
	Purpose
	Client → Server
	{"type":"subscribe"}
	WebSocketClient.connect()
	Subscribe to channels (pool, claims, etc.)
	Client → Server
	{"type":"unsubscribe"} (optional)
	custom UI / handler
	Unsubscribe from channels
	Client → Server
	{"type":"ping"} (optional)
	WebSocket client
	Keep-alive
	Server → Client
	POOL_UPDATED
	backend → useWebSocket
	Notify pool balance / metrics change
	Server → Client
	LIQUIDATION_DETECTED
	backend → useWebSocket
	Notify detected liquidation for a user
	Server → Client
	CLAIM_SUBMITTED
	backend → useWebSocket
	Notify claim started (tx sent)
	Server → Client
	CLAIM_PAID
	backend → useWebSocket
	Notify claim payout confirmed
	Server → Client
	pong (optional)
	backend
	Response to ping
	________________


3) Contract Interactions (frontend → blockchain via viem)
InsurancePool.sol
Type
	Function
	Called From
	Purpose
	write
	buyInsurance()
	useInsurance.buyInsurance()
	User buys insurance (pays premium)
	read
	getPoolStatus()
	usePool.fetchPoolStatus() (fallback)
	Directly read pool metrics if backend down
	Pricing.sol
Type
	Function
	Called From
	Purpose
	read
	premiumAmount()
	useInsurance.getPremiumFromContract()
	Compute premium on-chain (backup / compare)
	PolicyRegistry.sol
Type
	Function
	Called From
	Purpose
	read
	getPolicy()
	(optional) useInsurance / debug
	Read raw on-chain policy for current user
	These are all the touchpoints your React + Vite frontend uses to talk to the backend and contracts.


















































Backend Task Split - Web3 Dev (You) vs Full-Stack Dev (Your Friend)
________________


📊 Task Distribution Overview
text
┌─────────────────────────────────────────────────────────────┐
│                  Backend (Node.js)                          │
├──────────────────────────┬──────────────────────────────────┤
│                          │                                  │
│  YOU (Web3 Dev)          │  YOUR FRIEND (Full-Stack Dev)   │
│  ─────────────────       │  ─────────────────────────       │
│  Hyperliquid Integration │  REST API + Database            │
│  + Liquidation Monitor   │  + WebSocket Layer              │
│  + Contract Interactions │  + Authentication (optional)    │
│                          │                                  │
└──────────────────────────┴──────────────────────────────────┘


________________


🔷 TRACK 1: YOU (Web3 Dev) - Hyperliquid & Liquidation
Overview
You build the bridge between Hyperliquid and smart contracts. Your code:
* Monitors Hyperliquid for insured users
* Detects liquidations in real-time
* Submits claims to smart contracts
* Handles on-chain payout logic
________________


Task Breakdown
✅ Task 1.1: Set Up Project & Dependencies
What to do:
bash
# Clone repo and create your branch
git clone <repo>
git checkout -b feat/liquidation-monitor


# Install dependencies
npm install


# Install Web3-specific packages
npm install --save viem ethers node-cron dotenv


Create file: backend/src/config/viem.js
javascript
// backend/src/config/viem.js
import { createPublicClient, createWalletClient, http } from 'viem';
import { arbitrumSepolia } from 'viem/chains';


const rpcUrl = process.env.RPC_URL || 'http://127.0.0.1:8545';


export const publicClient = createPublicClient({
  chain: arbitrumSepolia,
  transport: http(rpcUrl),
});


export const walletClient = createWalletClient({
  chain: arbitrumSepolia,
  transport: http(rpcUrl),
  account: process.env.ADMIN_PRIVATE_KEY,
});


console.log('✅ VIEM clients initialized');


Create file: backend/.env (shared with friend)
text
# RPC & Blockchain
RPC_URL=http://127.0.0.1:8545
CHAIN_ID=31337
ADMIN_PRIVATE_KEY=0x...


# Smart Contracts
INSURANCE_POOL_ADDRESS=0x...
PRICING_ADDRESS=0x...
POLICY_REGISTRY_ADDRESS=0x...


# Hyperliquid (Production later)
HYPERLIQUID_API_URL=https://api.hyperliquid.xyz
MOCK_HYPERLIQUID=true  # Use mock data for MVP


# Database (Shared with friend)
DATABASE_URL=postgresql://user:pass@render-db-host:5432/safekeeper


Testing (Local):
bash
# Test that VIEM connects to local Hardhat network
node -e "import('./src/config/viem.js').then(() => console.log('✅ Connected'))"


When to test: Immediately after setup
________________


✅ Task 1.2: Create Contract ABIs & Helpers
What to do:
Create file: backend/src/config/contractABIs.js
javascript
// backend/src/config/contractABIs.js


export const INSURANCE_POOL_ABI = [
  {
    name: 'submitClaim',
    type: 'function',
    inputs: [
      { name: 'user', type: 'address' },
      { name: 'lossAmount', type: 'uint256' },
    ],
    outputs: [],
    stateMutability: 'nonpayable',
  },
  {
    name: 'getPoolStatus',
    type: 'function',
    inputs: [],
    outputs: [
      { name: 'balance', type: 'uint256' },
      { name: 'totalPremiums', type: 'uint256' },
      { name: 'totalClaims', type: 'uint256' },
      { name: 'activePolicies', type: 'uint256' },
    ],
    stateMutability: 'view',
  },
];


export const PRICING_ABI = [
  {
    name: 'premiumAmount',
    type: 'function',
    inputs: [
      { name: 'positionSize', type: 'uint256' },
      { name: 'leverage', type: 'uint256' },
      { name: 'volatility', type: 'uint256' },
    ],
    outputs: [{ name: '', type: 'uint256' }],
    stateMutability: 'pure',
  },
];


export const POLICY_REGISTRY_ABI = [
  {
    name: 'getPolicy',
    type: 'function',
    inputs: [{ name: 'user', type: 'address' }],
    outputs: [
      {
        name: '',
        type: 'tuple',
        components: [
          { name: 'user', type: 'address' },
          { name: 'positionSize', type: 'uint256' },
          { name: 'leverage', type: 'uint256' },
          { name: 'liquidationPrice', type: 'uint256' },
          { name: 'premiumPaid', type: 'uint256' },
          { name: 'createdAt', type: 'uint256' },
          { name: 'claimed', type: 'bool' },
          { name: 'claimedAt', type: 'uint256' },
        ],
      },
    ],
    stateMutability: 'view',
  },
];


What to test:
* ABIs are syntactically correct
* Can be imported without errors
When to test: Before Task 1.3
________________


✅ Task 1.3: Create Hyperliquid Service (Mock + Real)
What to do:
Create file: backend/src/services/hyperliquidService.js
javascript
// backend/src/services/hyperliquidService.js


import fetch from 'node-fetch';


const HYPERLIQUID_API = process.env.HYPERLIQUID_API_URL || 'https://api.hyperliquid.xyz';
const MOCK_MODE = process.env.MOCK_HYPERLIQUID === 'true';


/**
 * Check if a user's position on Hyperliquid is liquidated
 * @param {string} userAddress - User's wallet address
 * @param {object} policy - Policy from DB { liquidationPrice, positionSize, ... }
 * @returns {Promise<object>} { isLiquidated, currentPrice, position }
 */
export async function checkHyperliquidPosition(userAddress, policy) {
  if (MOCK_MODE) {
    return mockHyperliquidCheck(userAddress, policy);
  }


  try {
    console.log(`[HL] Checking position for ${userAddress}`);


    // Query Hyperliquid API
    const response = await fetch(`${HYPERLIQUID_API}/info`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        type: 'clearinghouseState',
        user: userAddress,
      }),
    });


    if (!response.ok) {
      throw new Error(`Hyperliquid API error: ${response.status}`);
    }


    const data = await response.json();
    const position = data.positions?.[0];


    if (!position) {
      console.log(`[HL] No active position for ${userAddress} (likely closed/liquidated)`);
      return {
        isLiquidated: true,
        reason: 'position_closed',
        currentPrice: null,
        position: null,
      };
    }


    const currentPrice = parseFloat(position.px);
    const liquidationPrice = parseFloat(policy.liquidationPrice);


    const isLiquidated = currentPrice <= liquidationPrice;


    if (isLiquidated) {
      console.log(`[HL] LIQUIDATION DETECTED: ${userAddress}`);
      console.log(`     Current price: $${currentPrice}, Liquidation price: $${liquidationPrice}`);
    }


    return {
      isLiquidated,
      currentPrice,
      position: {
        coin: position.coin,
        szi: position.szi, // position size
        px: position.px,
        liquidationPx: position.liquidationPx,
      },
    };
  } catch (error) {
    console.error(`[HL] Error checking position for ${userAddress}:`, error.message);
    return {
      isLiquidated: false,
      error: error.message,
    };
  }
}


/**
 * Mock Hyperliquid check (for MVP/testing without live API)
 */
function mockHyperliquidCheck(userAddress, policy) {
  // 10% chance of liquidation every check (for demo)
  const shouldLiquidate = Math.random() < 0.1;


  if (shouldLiquidate) {
    // Simulate price drop to liquidation level
    const liquidationPrice = parseFloat(policy.liquidationPrice);
    const droppedPrice = liquidationPrice * 0.99; // 1% below liquidation


    console.log(`[MOCK] Liquidation for ${userAddress}`);
    return {
      isLiquidated: true,
      currentPrice: droppedPrice,
      position: {
        coin: 'BTC',
        szi: policy.positionSize,
        px: droppedPrice,
      },
    };
  }


  // Otherwise, price is safe (95% of current liquidation price)
  const safePrice = parseFloat(policy.liquidationPrice) * 1.05;


  return {
    isLiquidated: false,
    currentPrice: safePrice,
    position: {
      coin: 'BTC',
      szi: policy.positionSize,
      px: safePrice,
    },
  };
}


/**
 * Get current price for any asset (for risk simulator frontend)
 */
export async function getAssetPrice(coin) {
  if (MOCK_MODE) {
    return { price: 45000 + Math.random() * 1000 };
  }


  try {
    const response = await fetch(`${HYPERLIQUID_API}/info`, {
      method: 'POST',
      body: JSON.stringify({ type: 'metaAndAssetCtxs' }),
    });


    const assets = await response.json();
    const asset = assets.find((a) => a.coin === coin);


    if (!asset) return null;


    return {
      price: parseFloat(asset.markPx),
      bid: parseFloat(asset.midPx) - 10, // approximate
      ask: parseFloat(asset.midPx) + 10,
    };
  } catch (error) {
    console.error(`Error fetching ${coin} price:`, error);
    return null;
  }
}


What to test:
* Mock mode works correctly (returns liquidated/safe states)
* Real API calls work (if you have Hyperliquid account)
* Error handling (API down, invalid user)
* Liquidation detection logic
Test file: backend/src/services/hyperliquidService.test.js
javascript
import { checkHyperliquidPosition } from './hyperliquidService.js';


const mockPolicy = {
  liquidationPrice: '2850',
  positionSize: '0.222',
};


console.log('Testing Hyperliquid Service...');


// Test 1: Mock liquidation
const result = await checkHyperliquidPosition('0x1234...', mockPolicy);
console.log('✅ Test 1 - Mock liquidation:', result);


// Test 2: Safe position
const result2 = await checkHyperliquidPosition('0x5678...', mockPolicy);
console.log('✅ Test 2 - Safe position:', result2);


When to test: After implementation, before moving to Task 1.4
________________


✅ Task 1.4: Create Claim Submission Service (Contract Calls)
What to do:
Create file: backend/src/services/claimSubmitter.js
javascript
// backend/src/services/claimSubmitter.js


import { walletClient, publicClient } from '../config/viem.js';
import { INSURANCE_POOL_ABI } from '../config/contractABIs.js';
import { parseEther } from 'viem';


const POOL_ADDRESS = process.env.INSURANCE_POOL_ADDRESS;
const MOCK_MODE = process.env.MOCK_HYPERLIQUID === 'true';


/**
 * Submit a claim to InsurancePool contract
 * @param {string} userAddress - User who should receive payout
 * @param {string} lossAmount - Loss amount (in wei)
 * @returns {Promise<string>} Transaction hash
 */
export async function submitClaimOnChain(userAddress, lossAmount) {
  if (MOCK_MODE) {
    return mockClaimSubmission(userAddress, lossAmount);
  }


  try {
    console.log(`[CLAIM] Submitting claim for ${userAddress}`);
    console.log(`[CLAIM] Loss amount: ${lossAmount} wei`);


    // Validate inputs
    if (!userAddress || userAddress === '0x0000000000000000000000000000000000000000') {
      throw new Error('Invalid user address');
    }


    if (BigInt(lossAmount) <= 0n) {
      throw new Error('Loss amount must be > 0');
    }


    // Call submitClaim on contract
    const txHash = await walletClient.writeContract({
      address: POOL_ADDRESS,
      abi: INSURANCE_POOL_ABI,
      functionName: 'submitClaim',
      args: [userAddress, BigInt(lossAmount)],
    });


    console.log(`[CLAIM] ✅ TX submitted: ${txHash}`);


    // Wait for confirmation
    const receipt = await publicClient.waitForTransactionReceipt({ hash: txHash });


    if (receipt.status !== 'success') {
      throw new Error(`Transaction failed: ${receipt.status}`);
    }


    console.log(`[CLAIM] ✅ TX confirmed in block ${receipt.blockNumber}`);


    return {
      txHash,
      blockNumber: receipt.blockNumber,
      gasUsed: receipt.gasUsed,
    };
  } catch (error) {
    console.error(`[CLAIM] ❌ Error submitting claim:`, error.message);
    throw error;
  }
}


/**
 * Mock claim submission (for MVP without live contracts)
 */
function mockClaimSubmission(userAddress, lossAmount) {
  const fakeTxHash = `0x${Math.random().toString(16).slice(2).padStart(64, '0')}`;


  console.log(`[MOCK-CLAIM] Simulated claim for ${userAddress}`);
  console.log(`[MOCK-CLAIM] Fake TX: ${fakeTxHash}`);


  return {
    txHash: fakeTxHash,
    blockNumber: Math.floor(Math.random() * 1000000),
    gasUsed: 150000n,
  };
}


/**
 * Get current pool status from contract
 */
export async function getPoolStatus() {
  try {
    const [balance, totalPremiums, totalClaims, activePolicies] =
      await publicClient.readContract({
        address: POOL_ADDRESS,
        abi: INSURANCE_POOL_ABI,
        functionName: 'getPoolStatus',
      });


    return {
      poolBalance: balance.toString(),
      totalPremiums: totalPremiums.toString(),
      totalClaims: totalClaims.toString(),
      activePolicies: activePolicies.toString(),
    };
  } catch (error) {
    console.error('[POOL] Error fetching pool status:', error);
    return null;
  }
}


What to test:
* Claim submission succeeds (mock mode)
* Transaction hash returned
* Error handling (invalid address, zero loss)
* Pool status read works
When to test: After implementation, before Task 1.5
________________


✅ Task 1.5: Create Liquidation Monitor (Cron Job)
What to do:
Create file: backend/src/jobs/liquidationMonitor.js
javascript
// backend/src/jobs/liquidationMonitor.js


import cron from 'node-cron';
import { PrismaClient } from '@prisma/client';
import { checkHyperliquidPosition } from '../services/hyperliquidService.js';
import { submitClaimOnChain, getPoolStatus } from '../services/claimSubmitter.js';


const prisma = new PrismaClient();
let isRunning = false;


/**
 * Start liquidation monitor cron job
 * Runs every 10 seconds in MVP
 */
export function startLiquidationMonitor(broadcastToWebSocket) {
  console.log('[MONITOR] Starting liquidation monitor...');


  cron.schedule('*/10 * * * * *', async () => {
    if (isRunning) {
      console.log('[MONITOR] ⏳ Previous check still running, skipping...');
      return;
    }


    isRunning = true;


    try {
      await checkAllPolicies(broadcastToWebSocket);
    } catch (error) {
      console.error('[MONITOR] ❌ Critical error in monitor:', error);
      broadcastToWebSocket('system_error', {
        type: 'MONITOR_ERROR',
        message: error.message,
      });
    } finally {
      isRunning = false;
    }
  });


  console.log('[MONITOR] ✅ Liquidation monitor started');
}


/**
 * Check all active policies for liquidations
 */
async function checkAllPolicies(broadcastToWebSocket) {
  console.log('[MONITOR] Checking policies...');


  const activePolicies = await prisma.policy.findMany({
    where: { status: 'ACTIVE' },
    include: { user: true },
  });


  console.log(`[MONITOR] Found ${activePolicies.length} active policies`);


  for (const policy of activePolicies) {
    try {
      await checkAndProcessLiquidation(policy, broadcastToWebSocket);
    } catch (error) {
      console.error(`[MONITOR] Error processing policy ${policy.id}:`, error.message);
      // Continue with next policy, don't crash
    }
  }


  // Periodically broadcast pool status
  const poolStatus = await getPoolStatus();
  if (poolStatus) {
    broadcastToWebSocket('pool_updates', {
      type: 'POOL_UPDATED',
      ...poolStatus,
      timestamp: new Date().toISOString(),
    });
  }
}


/**
 * Check single policy and submit claim if liquidated
 */
async function checkAndProcessLiquidation(policy, broadcastToWebSocket) {
  const result = await checkHyperliquidPosition(policy.userAddress, {
    liquidationPrice: policy.liquidationPrice,
    positionSize: policy.positionSize,
  });


  if (result.error) {
    console.warn(`[MONITOR] Skipping ${policy.userAddress} (API error)`);
    return;
  }


  if (!result.isLiquidated) {
    return; // Position is safe
  }


  console.log(`[MONITOR] 🔴 LIQUIDATION DETECTED: ${policy.userAddress}`);


  // Broadcast liquidation detected
  broadcastToWebSocket('liquidations', {
    type: 'LIQUIDATION_DETECTED',
    userAddress: policy.userAddress,
    positionSize: policy.positionSize,
    currentPrice: result.currentPrice,
    timestamp: new Date().toISOString(),
  });


  // Create claim in DB
  const claim = await prisma.claim.create({
    data: {
      userAddress: policy.userAddress,
      policyId: policy.id,
      lossAmount: policy.positionSize,
      payoutAmount: (BigInt(policy.positionSize) / 2n).toString(), // 50% coverage
      status: 'PENDING',
    },
  });


  console.log(`[MONITOR] 💾 Claim created: ${claim.id}`);


  try {
    // Submit claim on-chain
    const txResult = await submitClaimOnChain(
      policy.userAddress,
      claim.lossAmount
    );


    // Update claim in DB
    await prisma.claim.update({
      where: { id: claim.id },
      data: {
        txHash: txResult.txHash,
        status: 'SUBMITTED',
      },
    });


    // Mark policy as claimed
    await prisma.policy.update({
      where: { id: policy.id },
      data: { status: 'CLAIMED' },
    });


    console.log(`[MONITOR] ✅ Claim submitted: ${txResult.txHash}`);


    // Broadcast claim submitted
    broadcastToWebSocket('claims', {
      type: 'CLAIM_SUBMITTED',
      userAddress: policy.userAddress,
      lossAmount: policy.positionSize,
      payoutAmount: claim.payoutAmount,
      txHash: txResult.txHash,
      timestamp: new Date().toISOString(),
    });


    // In real scenario, you'd wait for finality
    // For now, assume immediate success
    await prisma.claim.update({
      where: { id: claim.id },
      data: {
        status: 'PAID',
        paidAt: new Date(),
      },
    });


    // Broadcast claim paid
    broadcastToWebSocket('claims', {
      type: 'CLAIM_PAID',
      userAddress: policy.userAddress,
      payoutAmount: claim.payoutAmount,
      txHash: txResult.txHash,
      timestamp: new Date().toISOString(),
    });


    console.log(`[MONITOR] 🎉 Claim processed for ${policy.userAddress}`);
  } catch (error) {
    console.error(`[MONITOR] ❌ Failed to submit claim:`, error.message);


    await prisma.claim.update({
      where: { id: claim.id },
      data: {
        status: 'FAILED',
      },
    });


    broadcastToWebSocket('claims', {
      type: 'CLAIM_FAILED',
      userAddress: policy.userAddress,
      error: error.message,
      timestamp: new Date().toISOString(),
    });
  }
}


export function stopLiquidationMonitor() {
  console.log('[MONITOR] Stopping liquidation monitor...');
  // Cron jobs auto-stop when process exits
}


What to test:
* Monitor starts without errors
* Detects mock liquidations
* Creates claims in DB
* Submits claims on-chain (mock)
* Broadcasts WebSocket events
* Handles errors gracefully
Test procedure:
bash
# In one terminal, run the monitor
node backend/src/jobs/liquidationMonitor.js


# In another terminal, insert test policies into DB
# (Your friend will help with this once DB is set up)


When to test: After friend sets up REST API and DB (Task 2)
________________


✅ Task 1.6: Create Web3 Utilities & Helpers
What to do:
Create file: backend/src/utils/web3.js
javascript
// backend/src/utils/web3.js


import { isAddress, getAddress } from 'viem';


/**
 * Validate Ethereum address
 */
export function isValidAddress(address) {
  return isAddress(address);
}


/**
 * Normalize address to checksum
 */
export function normalizeAddress(address) {
  try {
    return getAddress(address);
  } catch {
    throw new Error(`Invalid address: ${address}`);
  }
}


/**
 * Convert wei to ETH
 */
export function weiToEth(wei) {
  return Number(BigInt(wei)) / 1e18;
}


/**
 * Convert ETH to wei
 */
export function ethToWei(eth) {
  return BigInt(Math.floor(eth * 1e18));
}


/**
 * Format large numbers for display
 */
export function formatAmount(wei, decimals = 2) {
  const eth = weiToEth(wei);
  return eth.toFixed(decimals);
}


When to test: As you use these utilities
________________


✅ Task 1.7: Create Integration Tests (End-to-End)
What to do:
Create file: backend/src/jobs/liquidationMonitor.test.js
javascript
// backend/src/jobs/liquidationMonitor.test.js


import { PrismaClient } from '@prisma/client';


const prisma = new PrismaClient();


async function testLiquidationFlow() {
  console.log('Starting liquidation flow test...');


  try {
    // 1. Create test user
    const user = await prisma.user.create({
      data: {
        address: '0x1234567890123456789012345678901234567890',
      },
    });
    console.log('✅ Test user created:', user.id);


    // 2. Create test policy
    const policy = await prisma.policy.create({
      data: {
        userAddress: user.address,
        positionSize: '100000000000000000000', // 100 ETH
        leverage: 10,
        liquidationPrice: '285000000000000000000', // $2850
        premiumPaid: '1500000000000000000', // 1.5 ETH
        txHash: '0xabcd1234',
        status: 'ACTIVE',
      },
    });
    console.log('✅ Test policy created:', policy.id);


    // 3. Simulate liquidation detection
    console.log('Simulating liquidation...');
    const claim = await prisma.claim.create({
      data: {
        userAddress: user.address,
        policyId: policy.id,
        lossAmount: policy.positionSize,
        payoutAmount: '50000000000000000000', // 50 ETH (50% coverage)
        status: 'SUBMITTED',
        txHash: '0xdef5678',
      },
    });
    console.log('✅ Test claim created:', claim.id);


    // 4. Mark policy as claimed
    await prisma.policy.update({
      where: { id: policy.id },
      data: { status: 'CLAIMED' },
    });
    console.log('✅ Policy marked as claimed');


    // 5. Verify in DB
    const updatedClaim = await prisma.claim.findUnique({
      where: { id: claim.id },
    });
    console.log('✅ Verified claim status:', updatedClaim.status);


    console.log('\n🎉 All tests passed!');


    // Cleanup
    await prisma.claim.delete({ where: { id: claim.id } });
    await prisma.policy.delete({ where: { id: policy.id } });
    await prisma.user.delete({ where: { id: user.id } });
  } catch (error) {
    console.error('❌ Test failed:', error.message);
  } finally {
    await prisma.$disconnect();
  }
}


testLiquidationFlow();


When to test: After friend sets up database
________________


📋 Your Testing Checklist
After each task, test:
Task
	What to Test
	How to Test
	Expected Result
	1.1
	VIEM connection
	node src/config/viem.js
	Logs "✅ VIEM clients initialized"
	1.2
	ABI imports
	node -e "import('./src/config/contractABIs.js')"
	No errors
	1.3
	Hyperliquid service
	node src/services/hyperliquidService.test.js
	Returns liquidated/safe positions
	1.4
	Claim submitter
	node src/services/claimSubmitter.test.js
	Returns mock tx hash
	1.5
	Liquidation monitor
	Run cron job for 30 seconds
	Checks policies, detects liquidations
	1.6
	Web3 utilities
	Use them in other tests
	All conversions correct
	1.7
	Integration test
	node src/jobs/liquidationMonitor.test.js
	Create policy → claim → verify
	________________


🌳 Git Branch Strategy
bash
# Your branch
git checkout -b feat/liquidation-monitor


# Commit frequently
git add src/config/viem.js
git commit -m "feat: setup VIEM client config"


git add src/config/contractABIs.js
git commit -m "feat: add smart contract ABIs"


git add src/services/hyperliquidService.js
git commit -m "feat: implement Hyperliquid position checker"


# ... continue with other tasks


# Push to remote
git push origin feat/liquidation-monitor


# Create PR when ready for friend to review


________________


📝 Deliverables (By End of Your Tasks)
text
backend/src/
├── config/
│   ├── viem.js               ✅
│   └── contractABIs.js       ✅
├── services/
│   ├── hyperliquidService.js ✅
│   ├── claimSubmitter.js     ✅
│   └── index.js (export all) ✅
├── jobs/
│   ├── liquidationMonitor.js ✅
│   └── liquidationMonitor.test.js ✅
├── utils/
│   └── web3.js              ✅
└── (other files shared with friend)


________________


🔷 TRACK 2: YOUR FRIEND (Full-Stack Dev) - REST API & WebSocket
I'll create this in a follow-up message so it's clear. For now, this explains your part thoroughly.
________________


Summary: What You're Building
You're the bridge between reality (Hyperliquid) and the blockchain (Smart Contracts). Your responsibilities:
1. Monitor Hyperliquid for user liquidations every 10 seconds
2. Detect when a user's position hits their liquidation price
3. Submit claims to the InsurancePool contract
4. Broadcast events to frontend via WebSocket (your friend implements WS server)
5. Handle all Web3 logic (VIEM, contract calls, error handling)
Ready to start coding?